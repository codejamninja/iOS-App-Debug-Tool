"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _circularJson = _interopRequireDefault(require("circular-json"));

var _lodash = _interopRequireDefault(require("lodash"));

var _nodeIpc = _interopRequireDefault(require("node-ipc"));

var _path = _interopRequireDefault(require("path"));

var _pkgDir = _interopRequireDefault(require("pkg-dir"));

var _deasync = require("deasync");

var _2 = require(".");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const sockets = {};

class Socket {
  constructor(options = {}) {
    this.options = _objectSpread({
      cascadeStop: true,
      stopTimeout: 1000,
      timeout: 100
    }, options);
    this.ipc = _nodeIpc.default;
    this.ipc.config = _objectSpread({}, this.ipc.config, {
      retry: 1000,
      silent: true,
      id: require(_path.default.resolve(_pkgDir.default.sync(process.cwd()), 'package.json')).name || 'some-ipc-id'
    }, options.socket === true ? {} : options.socket);
    process.on('uncaughtException', err => {
      if (/Cannot read property 'config' of undefined/.test(err.message)) {
        process.exit();
      } else {
        throw err;
      }
    });
  }

  get owner() {
    if (this._owner) return this._owner;
    this._owner = !this.alive || !!this.server;
    return this._owner;
  }

  get alive() {
    const id = this.ipc.config.id;
    let alive = false;
    let done = false;

    try {
      this.ipc.connectTo(id, () => {
        this.ipc.of[id].on('getConfig.res', () => {
          alive = true;
          done = true;
        });
        this.ipc.of[id].emit('getConfig.req', {
          pid: process.pid
        });
        (0, _deasync.sleep)(this.options.timeout);
        done = true;
      });
    } catch (err) {
      done = true;
    }

    while (!done) {
      try {
        (0, _deasync.sleep)(100);
      } catch (err) {}
    }

    return alive;
  }

  get server() {
    return this.ipc.server;
  }

  set config(config = {}) {
    if (this.owner) {
      _lodash.default.each(sockets, socket => {
        this.ipc.server.emit(socket, 'updateConfig', {});
      });
    }
  }

  get config() {
    var _configs$name;

    const name = this.options.name;
    const id = this.ipc.config.id;
    let done = false;
    let config = null;
    if (this.owner) return ((_configs$name = _2.configs[name]) === null || _configs$name === void 0 ? void 0 : _configs$name.config) || null;

    try {
      this.ipc.connectTo(id, () => {
        this.listenToOwner();
        this.ipc.of[id].on('getConfig.res', res => {
          config = res.config;
          done = true;
        });
        this.ipc.of[id].emit('getConfig.req', {
          name,
          pid: process.pid
        });
        (0, _deasync.sleep)(this.options.timeout);
        done = true;
      });
    } catch (err) {
      done = true;
    }

    while (!done) {
      try {
        (0, _deasync.sleep)(100);
      } catch (err) {}
    }

    return config;
  }

  listenToOwner() {
    if (this.owner) return null;
    const id = this.ipc.config.id;
    if (this._listenToOwner) return null;
    this._listenToOwner = true;
    this.ipc.of[id].on('updateConfig', () => this.onUpdate(this.config));
    this.ipc.of[id].on('stop', () => {
      try {
        this.stop();
      } catch (err) {}
    });
    return null;
  }

  handleGetConfigRequest(req, socket) {
    var _configs$req$name;

    if (this.owner && req.pid) sockets[req.pid] = socket;
    let config = ((_configs$req$name = _2.configs[req.name]) === null || _configs$req$name === void 0 ? void 0 : _configs$req$name.config) || null;
    if (config) config = JSON.parse(_circularJson.default.stringify(config));
    this.ipc.server.emit(socket, 'getConfig.res', {
      config
    });
  }

  onUpdate(config) {
    return config;
  }

  start() {
    let done = false;
    this.ipc.serve(() => {
      this.ipc.server.on('getConfig.req', this.handleGetConfigRequest.bind(this));
      done = true;
    });
    this.ipc.server.start();

    while (!done) {
      try {
        (0, _deasync.sleep)(100);
      } catch (err) {}
    }

    return null;
  }

  stop() {
    const id = this.ipc.config.id;
    const _this$options = this.options,
          cascadeStop = _this$options.cascadeStop,
          stopTimeout = _this$options.stopTimeout;

    if (this.owner && cascadeStop) {
      _lodash.default.each(sockets, socket => {
        this.ipc.server.emit(socket, 'stop', {});
      });
    }

    this.ipc.disconnect(id);
    const server = this.ipc.server;

    if (server) {
      if (server.server) _nodeIpc.default.server.server.close();
      server.stop();
      setTimeout(() => {
        process.exit();
      }, stopTimeout);
    }

    return null;
  }

}

exports.default = Socket;