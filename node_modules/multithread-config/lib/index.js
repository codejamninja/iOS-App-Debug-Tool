"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.configs = void 0;

var _path = _interopRequireDefault(require("path"));

var _pkgDir = _interopRequireDefault(require("pkg-dir"));

var _socket = _interopRequireDefault(require("./socket"));

var _state = _interopRequireDefault(require("./state"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const configs = {};
exports.configs = configs;

class MultithreadConfig {
  constructor(options) {
    this.options = _objectSpread({
      timeout: 100,
      socket: true,
      name: require(_path.default.resolve(_pkgDir.default.sync(process.cwd()), 'package.json')).name || 'some-config'
    }, options);

    if (this.options.socket) {
      this.socket = new _socket.default(this.options);

      this.socket.onUpdate = config => {
        const name = this.options.name;
        if (!configs[name]) configs[name] = new _state.default();
        configs[name].config = config;
        this.onUpdate(configs[name].config);
      };
    }
  }

  get owner() {
    if (this._owner) return this._owner;
    const socket = this.options.socket;

    if (!socket) {
      this._owner = true;
    } else {
      this._owner = this.socket.owner;
    }

    return this._owner;
  }

  get free() {
    return !this.config;
  }

  set config(config = {}) {
    const _this$options = this.options,
          name = _this$options.name,
          socket = _this$options.socket;

    if (socket) {
      if (!this.socket.alive) this.socket.start();
    }

    if (!this.owner) throw new Error('process is not the owner of config');
    if (this.free) configs[name] = new _state.default();
    configs[name].config = config;
    if (socket) this.socket.config = configs[name].config;
    return configs[name].config;
  }

  get config() {
    const name = this.options.name;
    if (!configs[name]) configs[name] = new _state.default();

    if (!this.owner) {
      let config = null;

      try {
        config = this.socket.config;
      } catch (err) {}

      if (config) configs[name].config = config;
    }

    return configs[name].config;
  }

  get alive() {
    return this.socket.alive();
  }

  onUpdate(config) {
    return config;
  }

  stop() {
    if (this.socket) {
      try {
        return this.socket.stop();
      } catch (err) {}
    }

    return null;
  }

}

exports.default = MultithreadConfig;